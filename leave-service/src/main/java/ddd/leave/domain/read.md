# 领域层
核心业务逻辑相关的代码

领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。
聚合以及聚合内的实体、方法、领域服务和事件等代码会放在这一层目录里

# 各层目录
聚合内的代码模型是标准和统一的，包括：entity、event、repository 和 service 四个子目录

Event（事件）： 它存放事件实体以及与事件活动相关的*业务逻辑*代码。

Entity（实体）： 它存放聚合根、实体、值对象以及工厂模式（Factory）相关代码。
实体类采用 充血模型，同一实体相关的业务逻辑都在*实体类代码*中实现，相对简单的原子业务逻辑
跨实体的业务逻辑代码在*领域服务*中实现。

Aggregate（聚合）： 它是聚合软件包的根目录，可以根据实际项目的聚合名称命名，比如权限聚合。
在聚合内定义聚合根、实体和值对象以及领域服务之间的关系和边界。聚合内实现高内聚的业务逻辑，它的代码可以独立拆分为微服务。
以聚合为单位的代码放在一个包里的主要目的是为了业务内聚，而更大的目的是为了以后微服务之间聚合的重组。
聚合之间清晰的代码边界，可以让你轻松地实现以聚合为单位的微服务重组，在微服务架构演进中有着很重要的作用。

Service（领域服务）： 它存放领域服务代码。
一个领域服务是多个实体组合出来的一段业务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中，你也可以把每一个领域服务设计为一个类。
如果领域服务内的业务逻辑相对复杂，将一个领域服务设计为一个领域服务类，避免由于所有领域服务代码都放在一个领域服务类中，而出现代码臃肿的问题。
领域服务封装多个实体或方法后向上层提供应用服务调用。

*开发领域服务或实体方法中，避免调用其他聚合的领域服务或引用其他聚合的实体或值对象*

Repository（仓储）： 它存放所在聚合的查询或持久化领域对象的代码，通常包括仓储接口和仓储实现方法。为了方便聚合的拆分和组合，我们设定了一个原则：一个聚合对应一个仓储
